package streaming

import (
	"fmt"
	"os"
	"strings"

	"gopkg.in/yaml.v3"
)

// Go2RTCConfig represents the go2rtc configuration file structure
type Go2RTCConfig struct {
	API     APIConfig              `yaml:"api,omitempty"`
	RTSP    RTSPConfig             `yaml:"rtsp,omitempty"`
	WebRTC  WebRTCConfig           `yaml:"webrtc,omitempty"`
	Streams map[string][]string    `yaml:"streams,omitempty"`
	Log     LogConfig              `yaml:"log,omitempty"`
}

// APIConfig represents go2rtc API configuration
type APIConfig struct {
	Listen   string `yaml:"listen,omitempty"`
	BasePath string `yaml:"base_path,omitempty"`
	Origin   string `yaml:"origin,omitempty"`
	TLSListen string `yaml:"tls_listen,omitempty"`
}

// RTSPConfig represents go2rtc RTSP configuration
type RTSPConfig struct {
	Listen       string `yaml:"listen,omitempty"`
	DefaultQuery string `yaml:"default_query,omitempty"`
}

// WebRTCConfig represents go2rtc WebRTC configuration
type WebRTCConfig struct {
	Listen     string   `yaml:"listen,omitempty"`
	Candidates []string `yaml:"candidates,omitempty"`
}

// LogConfig represents go2rtc logging configuration
type LogConfig struct {
	Level  string `yaml:"level,omitempty"`
	Format string `yaml:"format,omitempty"`
}

// CameraStream represents a camera's stream configuration
type CameraStream struct {
	ID       string
	Name     string
	URL      string
	Username string
	Password string
	SubURL   string // Sub-stream URL (optional)
}

// ConfigGenerator generates go2rtc configuration from camera configs
type ConfigGenerator struct {
	apiPort    int
	rtspPort   int
	webrtcPort int
}

// NewConfigGenerator creates a new config generator
func NewConfigGenerator() *ConfigGenerator {
	return &ConfigGenerator{
		apiPort:    DefaultGo2RTCPort,
		rtspPort:   DefaultRTSPPort,
		webrtcPort: DefaultWebRTCPort,
	}
}

// WithPorts sets custom ports for the generator
func (g *ConfigGenerator) WithPorts(api, rtsp, webrtc int) *ConfigGenerator {
	g.apiPort = api
	g.rtspPort = rtsp
	g.webrtcPort = webrtc
	return g
}

// Generate generates a go2rtc config from camera streams
func (g *ConfigGenerator) Generate(cameras []CameraStream) *Go2RTCConfig {
	config := &Go2RTCConfig{
		API: APIConfig{
			Listen:   fmt.Sprintf(":%d", g.apiPort),
			BasePath: "",
			// Allow all origins for development
			// go2rtc requires "*" to allow cross-origin WebSocket connections
			Origin:   "*",
		},
		RTSP: RTSPConfig{
			Listen:       fmt.Sprintf(":%d", g.rtspPort),
			DefaultQuery: "video&audio",
		},
		WebRTC: WebRTCConfig{
			Listen: fmt.Sprintf(":%d/tcp", g.webrtcPort),
			Candidates: []string{
				"stun:stun.l.google.com:19302",
			},
		},
		Streams: make(map[string][]string),
		Log: LogConfig{
			Level:  "info",
			Format: "text",
		},
	}

	for _, cam := range cameras {
		streamURL := g.buildStreamURL(cam.URL, cam.Username, cam.Password)
		streamName := sanitizeStreamName(cam.ID)

		// Use ffmpeg for all streams to ensure proper audio transcoding to opus
		// The #video=copy#audio=opus approach:
		// - Copies video without re-encoding (fast, no quality loss)
		// - Transcodes audio to opus (required for WebRTC compatibility)
		// This is more reliable than the two-source approach
		if strings.HasPrefix(streamURL, "ffmpeg:") {
			// Already an ffmpeg source, add audio transcoding parameters
			streamURL = streamURL + "#video=copy#audio=opus"
			config.Streams[streamName] = []string{streamURL}
		} else {
			// Wrap all streams with ffmpeg for consistent audio transcoding
			config.Streams[streamName] = []string{
				fmt.Sprintf("ffmpeg:%s#video=copy#audio=opus", streamURL),
			}
		}

		// Sub stream if available
		if cam.SubURL != "" {
			subStreamURL := g.buildStreamURL(cam.SubURL, cam.Username, cam.Password)
			subStreamName := streamName + "_sub"

			if strings.HasPrefix(subStreamURL, "ffmpeg:") {
				subStreamURL = subStreamURL + "#video=copy#audio=opus"
				config.Streams[subStreamName] = []string{subStreamURL}
			} else {
				config.Streams[subStreamName] = []string{
					fmt.Sprintf("ffmpeg:%s#video=copy#audio=opus", subStreamURL),
				}
			}
		}
	}

	return config
}

// WriteToFile writes the configuration to a YAML file
func (g *ConfigGenerator) WriteToFile(config *Go2RTCConfig, path string) error {
	data, err := yaml.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	// Add header comment
	header := "# go2rtc configuration\n# Auto-generated by NVR System - manual edits may be overwritten\n\n"
	data = append([]byte(header), data...)

	if err := os.WriteFile(path, data, 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

// buildStreamURL builds a stream URL with credentials and transcoding options
func (g *ConfigGenerator) buildStreamURL(url, username, password string) string {
	result := url

	// Add credentials if provided
	if username != "" {
		// Parse and rebuild URL with credentials
		// Handle rtsp:// URLs
		if strings.HasPrefix(url, "rtsp://") {
			host := strings.TrimPrefix(url, "rtsp://")
			if password != "" {
				result = fmt.Sprintf("rtsp://%s:%s@%s", username, password, host)
			} else {
				result = fmt.Sprintf("rtsp://%s@%s", username, host)
			}
		} else if strings.HasPrefix(url, "http://") {
			// Handle http:// URLs
			host := strings.TrimPrefix(url, "http://")
			if password != "" {
				result = fmt.Sprintf("http://%s:%s@%s", username, password, host)
			} else {
				result = fmt.Sprintf("http://%s@%s", username, host)
			}
		} else if strings.HasPrefix(url, "https://") {
			// Handle https:// URLs
			host := strings.TrimPrefix(url, "https://")
			if password != "" {
				result = fmt.Sprintf("https://%s:%s@%s", username, password, host)
			} else {
				result = fmt.Sprintf("https://%s@%s", username, host)
			}
		}
	}

	// Note: We no longer force H264 transcoding here
	// The VideoPlayer will try native H265 first, and request H264 transcoding
	// via the stream URL parameter if the browser doesn't support H265

	return result
}

// sanitizeStreamName ensures the stream name is valid for go2rtc
func sanitizeStreamName(name string) string {
	// Replace invalid characters with underscores
	replacer := strings.NewReplacer(
		" ", "_",
		"-", "_",
		".", "_",
		"/", "_",
		"\\", "_",
	)
	return strings.ToLower(replacer.Replace(name))
}

// GetStreamURL returns the go2rtc stream URL for a camera
func GetStreamURL(cameraID string, format string, apiPort int) string {
	streamName := sanitizeStreamName(cameraID)
	baseURL := fmt.Sprintf("http://localhost:%d", apiPort)

	switch format {
	case "rtsp":
		return fmt.Sprintf("rtsp://localhost:%d/%s", DefaultRTSPPort, streamName)
	case "webrtc":
		return fmt.Sprintf("%s/api/webrtc?src=%s", baseURL, streamName)
	case "hls":
		return fmt.Sprintf("%s/api/stream.m3u8?src=%s", baseURL, streamName)
	case "mse":
		return fmt.Sprintf("%s/api/ws?src=%s", baseURL, streamName)
	case "mjpeg":
		return fmt.Sprintf("%s/api/frame.jpeg?src=%s", baseURL, streamName)
	default:
		return fmt.Sprintf("%s/api/stream.m3u8?src=%s", baseURL, streamName)
	}
}
